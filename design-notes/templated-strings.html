<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>templated-strings</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
      <style type="text/css">
        A IMG { border-width: 0px; }
  
        BODY {
            background: white;
            margin: 2em;
          font-size: medium;
          max-width: 60em;
          margin-bottom: 100%;
          font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji;
        }
  
        code, pre, tt {
  	font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  	font-size: medium
        }
  
        code {
            display: inline-block;
            padding: .1em .2em;
          font-size: 90%;
          border-radius: 6px;
  	background-color: #f6f8fa;
          box-sizing: border-box;
        }
  
        h1 {
  	  font-size: 32px;
        }
  
        h1,
        h2 {
  	  font-weight: 600;
            border-bottom: 1px solid #e8e8e8;
        }
        
        h2 {
  	  font-size: 24px
        }
        
        h3 {
  	  font-size: 20px
        }
        
        h3,
        h4 {
  	  font-weight: 600
        }
        
        h4 {
  	  font-size: 20px
        }
  
        P { margin: 1ex 0em; }
        P.subsection { margin-top: 2ex; }
        P.subsection:first-child { margin-top: 1ex; }
        P SPAN.title { font-weight: bold; padding-right: 1em; }
  
        PRE {
          margin: 1.5ex 2em;
          padding: 1px 1ex;
          background: #f6f8fa;
        }
  
        .sidebar {
          margin: 1.5ex 2em;
          padding: 1px 1ex;
          background: #e8e8e8;
        }
  
        .control-character {
            color: #bbb;
            font-style: italic;
        }
  
        /* added for ```{.jvm} support */
        PRE.jvm { font-style: italic; }
  
        BLOCKQUOTE { margin: 1.5ex 2em; font-style: italic; border-left: 0.2em solid gray; padding-left: 1em; }
        LI BLOCKQUOTE { margin-left: 0em; }
        LI { margin: 0ex 0em; }
  
        TABLE, TH, TD { border: 1px solid #e8e8e8;
                        padding: 6px 12px; }
        TR:nth-child(2n) {
            background-color: #f6f8fa;
        }
        TH { font-weight: 600 }
        TABLE { border-collapse: collapse; }
        TD { vertical-align: top; }
  
        UL LI { list-style-type: square; }
  
        DIV.summary { margin: 2ex 2em; }
  
        DIV.head { margin-bottom: 2em; }
        DIV.doctitle { font-size: x-large; font-weight: bold; }
        DIV.twarn { color: #cc0000; font-size: smaller; font-weight: bold;
                    margin-bottom: 1.5ex; }
        DIV.authors { margin-top: 1ex; font-size: large; }
        DIV.author A { font-style: italic; }
        DIV.version { font-size: medium; margin-top: 1ex; }
        DIV.copyright, DIV.comments { font-size: small; }
        DIV.version SPAN.modified { color: green; font-weight: bold; }
        DIV.head DIV.notes { margin-top: 1ex; }
        DIV.qa { margin-top: 2ex; }
        DIV.footer { padding-top: 4em; text-align: center; font-size: 7pt; }
        
        /* added because pandoc syntax highlighting always uses scroll bars */
        DIV.sourceCode {
            overflow: visible;
        }
  
        HR { border: 0px; border-top: 1px solid black; margin: 2ex 0em; }
     </style>
</head>
<body>
<h3 id="string-tapas-redux-beyond-mere-string-interpolation">String Tapas Redux: Beyond mere string interpolation</h3>
<h4 id="jim-laskey-and-brian-goetz-september-2021">Jim Laskey and Brian Goetz September 2021</h4>
<p>Some time ago, we talked about all the things we might want to do with strings: multi-line strings, raw strings, interpolated strings. At the time, we sated our appetite with the first course – text blocks – and now are ready to talk about what we can do next.</p>
<p>It is one of the most commonly requested features to support some sort of <em>string interpolation</em>, which is useful for formatting log messages and snippets of HTML, JSON, XML, or SQL. While Java already has many ways to combine constant strings with non-constant values (concatenation, <code>String::format</code>, <code>MessageFormat</code>), developers would prefer something more direct, for several reasons:</p>
<ul>
<li><strong>Ceremony</strong>. Writing string interpolation expressions, rather than calls to template-formatting libraries, is less work.</li>
<li><strong>Readability</strong>. In many cases (though not all) a string interpolation expression like <code>"My name is ${name}, I am ${age} years old"</code> is more readable than its equivalent with <code>String::format</code>, because the labels (“My name is”) and the corresponding parameters are right next to each other.</li>
<li><strong>Safety</strong>. A long format string or a long list of interpolants invites mistakes, such as the arity of parameters not matching that of format specifiers, or the types of the parameters not matching the corresponding format specifiers.</li>
</ul>
<p>However, there are reasons we’ve been hesitant to do such a feature, including:</p>
<ul>
<li><strong>Injection attacks</strong>. Constructing SQL queries or JSON expressions with string interpolation is convenient, but is at risk for <a href="https://xkcd.com/327/">injection attacks</a>. Improving mechanisms for constructing composite strings without similarly improving or enabling safer mechanisms for constructing queries would surely widen the attack surface. This is asking users to choose between convenience and security.</li>
<li><strong>Localization</strong>. Java has a strong commitment to internationalization; introducing a more convenient but less localizable mechanism for constructing messages will result in fewer applications being localized. This is asking users to choose between convenience and flexibility.</li>
<li><strong>Formatting</strong>. A naive interpretation of string interpolation deprives us of the ability to format with format specifiers such as field widths, locale-sensitive numeric formatting, etc. This is asking users to choose between convenience and expressiveness.</li>
</ul>
<p>The versions of this feature implemented by many popular languages offer the desired convenience in the simple cases, but fall afoul of many of these downsides. We may want the convenience of string interpolation, but we also want safety and flexibility across a range of domains.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Language          </th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">C#</td>
<td style="text-align: left;"><code>$"{x} plus {y} equals {x + y}"</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Groovy</td>
<td style="text-align: left;"><code>"$x plus $y equals ${x + y}"</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Haskell</td>
<td style="text-align: left;"><code>[i\|#{x} plus #{y} equals #{x + y}\|]</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">JavaScript</td>
<td style="text-align: left;">`<code>${x} plus ${y} equals ${x + y}</code>`</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Kotlin</td>
<td style="text-align: left;"><code>"$x plus $y equals ${x + y}"</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Scala</td>
<td style="text-align: left;"><code>f"$x%d plus $y%d equals ${x + y}%d"</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Python</td>
<td style="text-align: left;"><code>f"{x} plus {y} equals {x + y}"</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Ruby</td>
<td style="text-align: left;"><code>"#{x} plus #{y} equals #{x + y}"</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Swift</td>
<td style="text-align: left;"><code>"\(x) plus \(y) equals \(x + y)"</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">VisualBasic</td>
<td style="text-align: left;"><code>$"{x} plus {y} equals {x + y}"</code></td>
</tr>
</tbody>
</table>
<p>We’re not interested in merely doing “string interpolation” as it has been interpreted by other languages. We would like to do better.</p>
<h4 id="whats-wrong-with-string-interpolation">What’s wrong with string interpolation?</h4>
<p>The only case handled by most other languages that support string interpolation is the simplest one – uninterpreted concatenation. Picking an example at random:</p>
<pre><code>// Scala
val greeting = s&quot;Hello, $name, I am $age years old&quot;</code></pre>
<p>The feature illustrated here is constrained in many ways: the format string is not validated, the parameters are not validated or transformed in any way, the parts are combined by a very constrained mechanism (the result must be exactly the segments of the format string concatenated with the string value of the parameters), and finally, the result must be a <code>String</code>. While these might be convenient defaults, not being able to customize any of these behaviors is a severe limitation.</p>
<p>In addition, the surfacing of the feature in the language is confusingly ad-hoc; it requires a different delimiter from “regular” strings, as well as a different set of rules for separating verbatim content from embedded expressions. In the first course (text blocks), an important goal was that string literals and text blocks be different stackings of the same basic feature, rather than wholly separate features (this is one reason “raw string literals” was withdrawn.) We would like to follow the same discipline here; embedded parameters should be part of the overall string expression feature, not a separate thing.</p>
<h4 id="another-level-of-indirection">Another level of indirection</h4>
<p>We can meet our diverse goals by separating <em>mechanism</em> from <em>policy</em>. How we introduce parameters into string expressions is mechanism; how we combine the parameters and the string into a final result (e.g., concatenation) is policy. The language may need to have an opinion about how a templatized expression is expressed, but the semantics of how parameters are validated, transformed, and combined should remain in the hands of ordinary library code. Users should be able to select the templating policy they want, and be able to capture templating policies in libraries for reuse.</p>
<p>A templating policy might be described by an interface like:</p>
<pre><code>interface TemplatePolicy&lt;T&gt; {
    T apply(String templateString, List&lt;Object&gt; parameters);
}</code></pre>
<p>An implementation of a template policy is an ordinary object that implements some parameterization of <code>TemplatePolicy</code>. The simplest template policy is what every other language does – concatenation – and can be exposed by the standard libraries.</p>
<p>We can express template processing as <em>instance behavior</em> on a policy object:</p>
<pre><code>String s = STR.&quot;Hello \{name}, I am \{age} years old.&quot;;</code></pre>
<p>where <code>STR</code> is a static instance of <code>TemplatePolicy</code> which captures the obvious policy.</p>
<p>The escape sequence <code>\{</code> is currently unused (and therefore currently illegal in string literals and text blocks), so this choice of parameter carrier is compatible with the existing string literal and text block features. (Swift uses <code>\(...)</code>, which would also be a valid choice.) This means we do not need to invent a new form (or two) of “string template expression” with a different delimiter or prefix character.</p>
<p>The policy object has the flexibility to validate the format string and parameters, interpret the format string and parameters as it sees fit, combine them as it sees fit (not just sequential concatenation), and produce a result that is not even a <code>String</code>. The compiler shreds a parameterized string expression into the constant and non-constant parts, and arranges for the combination method on the policy object to be invoked.</p>
<h4 id="examples">Examples</h4>
<p>Delegating control to a policy object dramatically expands the expressiveness and safety of the feature.</p>
<p><strong>String formatting.</strong> Formatting libraries like <code>String::format</code> offer more than just interpolation; they offer rich formatting options such as field-width management, leading-zero fills, hex conversion, locale-specific presentation, etc. Making straight interpolation easier but no improvement for formatting libraries leaves users with an unpleasant choice of convenience or rich formatting. If we wanted to format the number <code>age</code> using the various modifiers supported by the <code>%d</code> format specifier, we wouldn’t want to abandon the convenience of the straightforward expression.</p>
<p>On the other hand, it would be folly to bake the <code>String::format</code> descriptor language into the Java language; representation and interpretation of the format specifiers should be under the control of the template policy. But we can encapsulate this in a library that implements this set of format specifiers, and exposes a constant policy object. Here, <code>FMT</code> is a policy object that interprets a set of format specifiers that are similar to <code>printf</code> / <code>String::format</code>, using the convention that the format specifier goes right before the “hole”:</p>
<pre><code>String s = FMT.&quot;Hello %s\{name}, I am %10d\{age} years old.&quot;;</code></pre>
<p>When the format string is shredded into constant and variable parts, the end of each constant part should contain a format descriptor which is used to condition the formatting of the following parameter (and the policy object can validate this). The Java language knows nothing of the format descriptor language; this is interpreted solely by the formatter library.</p>
<p>Even ignoring the choice of format descriptor language, library methods like <code>String::format</code> often embody difficult choices, such as whether or not to use the currently selected <code>Locale</code> to format numeric quantities. Some users like the flexibility they get from such automatic localization; others resent the performance overhead of <code>Locale</code> processing. By exposing a mechanism by which users and libraries can implement their own formatters, users are not constrained by these choices made by libraries on their behalf – there could be both locale-sensitive and locale-insensitive formatters for the same domain, and the user can choose the one they want.</p>
<p><strong>Validation and normalization.</strong> SQL statements are often parameterized by some dynamic data value. Unfortunately, the data being interpolated is often tainted by user input. The JDBC framework includes builders for <em>prepared statements</em>, which sanitize inputs and compose the query in a SQL-aware manner:</p>
<pre><code>PreparedStatement ps
    = connection.prepareStatement(&quot;SELECT * FROM Person p where p.last_name = ?&quot;);
ps.setString(1, name);</code></pre>
<p>This will escape any <code>'</code> characters in <code>name</code> and surround it with <code>'</code> characters before performing the interpolation. If <code>name</code> is <code>"Bobby"</code>, the resulting query will be <code>SELECT * FROM Person p where p.last_name = 'Bobby'</code>.</p>
<p>With a convenient string interpolation feature, it is sorely tempting to construct SQL queries with:</p>
<pre><code>String query = &quot;SELECT * FROM Person p where p.last_name = &#39;$name&#39;&quot;;
ResultSet rs = connection.createStatement().executeQuery(query);</code></pre>
<p>Unfortunately, this now exposes the application to potentially disastrous SQL injection attacks unless <code>name</code> has been previously sanitized. Trading security for convenience is not a good trade.</p>
<p>We can get the best of both worlds with a SQL-specific policy object that performs the sanitization that <code>PreparedStatement</code> does, and more:</p>
<ul>
<li>Enforce that any quotes in the format string itself are balanced.</li>
<li>Enforce that interpolation points do not occur in “quoted” parts of the format string.</li>
<li>Wrap parameters with quotes.</li>
<li>Escape any quote characters in parameters.</li>
</ul>
<p>SQL databases generally follow a common set of rules around single-quotes, but some databases also have other supported forms of quotes. To the extent that a given database has its own nonstandard quoting rules, we would like to defend against attacks that exploit those as well. This means that we don’t just need a SQL-specific policy object; we need a <code>Connection</code>-specific policy object, because the <code>Connection</code> comes from the JDBC driver for the specific database we’re talking to.</p>
<p>While there are many API choices that JDBC might select, one might be to make <code>Connection</code> also be a policy object; then we could ask the connection to format the query directly:</p>
<pre><code>var query = connection.&quot;SELECT * FROM \{table}&quot;;</code></pre>
<p><strong>Non-string results.</strong> One could easily imagine a JSON or XML library providing a similar level of quote discipline and injection protection in those domains (they are vulnerable to injection attacks too):</p>
<pre><code>String s = JSON.&quot;&quot;&quot;
                {
                   &quot;a&quot;: \{a},
                   &quot;b&quot;: \{b}
                }
                &quot;&quot;&quot;;</code></pre>
<p>The policy referred to by <code>JSON</code> would perform the proper validation of the format string, and quoting and escaping of the parameters <code>a</code> and <code>b</code> before composing the final string.</p>
<p>But, do we even want to produce a string at all? Many JSON libraries allow us to represent JSON documents through a <code>Json</code> type; it might be more efficient for the JSON policy object to go directly to that representation rather than first constructing a (potentially large) string and then parsing the resulting string. While some policy objects will surely want to produce strings, there’s no reason all of them do. Our policy interface can be parameterized by the type it returns, as <code>TemplatePolicy</code> illustrated. So this JSON example could be:</p>
<pre><code>Json j = JSON.&quot;&quot;&quot;
              {
                 &quot;a&quot;: \{a},
                 &quot;b&quot;: \{b}
              }
              &quot;&quot;&quot;;</code></pre>
<p>which is more direct and potentially more efficient.</p>
<p>Another use for non-string results is when formatting messages for logging. Many logging calls are for debug information, and often debug logging is turned off. Many frameworks allow you to provide a <code>Supplier&lt;String&gt;</code> for log messages that is only invoked if the message is actually going to be logged, to avoid the overhead of formatting a string that is going to be thrown away. A lazy policy object could produce <code>Supplier&lt;String&gt;</code> rather than <code>String</code> itself.</p>
<p><strong>Localization.</strong> The examples so far have been about interpolation enhanced with validation and transformation, but this can be taken further. The JDK contains APIs such as <code>ResourceBundle</code> to support localization of messages. A resource bundle is a mapping from key names to localizable template strings. (These template strings use a different format than <code>String::format</code>, in part because they must support changing the order of parameters as part of the localization process; the interpolation “hole” in the localized template contains the index of the corresponding parameter.)</p>
<p>If resource bundles had a <code>TemplatePolicy</code>, then they could use the format string as a key to look up the localized string, and then perform the interpolation, all in one go:</p>
<pre><code>String message = resourceBundle.&quot;error: file \{filename} not found&quot;;</code></pre>
<p>which would have the effect of using the string <code>"error: file \{} not found"</code> as the key, mapping it to an appropriate localized error message for the current locale, reordering the parameters according to the <code>{nn}</code> holes in the localized messages, and formatting the result using the <code>MessageFormat</code> rules.</p>
<h2 id="templated-strings">Templated Strings</h2>
<p>A reasonable question is what should a templated string expression <em>without</em> a policy evaluate to? For those who “just” want string interpolation, the “obvious” answer is to use the concatenation policy, but there is a better choice: evaluate to an “unprocessed” string template, which can be passed to a library for later processing. We can model an unprocessed template as:</p>
<pre><code>interface TemplatedString {
    String formatString();
    List&lt;Object&gt; parameters();
    // more
}</code></pre>
<p>and say that the following:</p>
<pre><code>var s = &quot;Hello, \{name}, I am \{age} years old&quot;;</code></pre>
<p>evaluates to a <code>TemplatedString</code>. Libraries like <code>String::format</code> can provide overloads that accept templated strings, so templated strings can be passed directly to libraries:</p>
<pre><code>String format(String formatString, Object... parameters);
String format(TemplatedString ts);</code></pre>
<p>We can now recast our policy interface to take a templated string:</p>
<pre><code>interface TemplatingPolicy&lt;T, E extends Exception&gt; {
    T apply(TemplatedString ts) throws E;
}</code></pre>
<p>(We’ve also snuck in another parameter, that allows policies to declare that they throw checked exceptions that callers would have to deal with, such as <code>SQLException</code>, though most will likely instantiate <code>E</code> with <code>RuntimeException</code>.)</p>
<h2 id="restrictions">Restrictions</h2>
<p>We may wish to place some syntactic restrictions on the parameters to limit readability and safety hazards (at the expense of expressiveness). At one extreme of the spectrum, we could restrict to only allowing identifiers, as <code>bash</code> does, but this is surely too restrictive. At the other extreme, we could allow arbitrary expressions. But, Java’s expressions cover a broad range, including string literals (which could create confusion over what is part of the format string and what is parameter), switch expressions (which can contain statements), and auto-incrementing expressions (which have side-effects); we may want to prune this back to eliminate puzzlers-in-waiting.</p>
<p>A possible middle ground is the subset of expressions generated from numeric literals, variables, field selection, arithmetic operators, and array dereference. This is rich enough to describe parameters like <code>a.b[i-1]</code> or <code>fooCount+barCount</code>, but is guaranteed side-effect-free and does not contain embedded string literals.</p>
<h2 id="translation">Translation</h2>
<p>The policy APIs shown here have the drawback of primitive and array boxing; further, for formatting such as that performed by <code>String::format</code>, much of the work is in scanning the format string, which is usually a constant at a given invocation site. There are opportunities for more efficient translation with <code>invokedynamic</code> that avoids these pitfalls. We wish to achieve a balance between making it easy for libraries to implement templating policies, and allowing policies (such as the <code>String::format</code> equivalent) to support a more efficient translation; the details of this will be covered separately.</p>
<div class="footer" id="footer">
<img src="http://openjdk.java.net/images/openjdk-small.png">
<br>© 2021 Oracle Corporation and/or its affiliates
<br><a href="http://openjdk.java.net/legal/tou/">Terms of Use</a>
· License: <a href="http://openjdk.java.net/legal/gplv2+ce.html">GPLv2</a>
· <a href="http://www.oracle.com/us/legal/privacy/">Privacy</a>
· <a href="http://www.oracle.com/us/legal/third-party-trademarks/third-party-trademarks-078568.html">Trademarks</a>
</div>
</body>
</html>
